import logging
import functools
from typing import Any, Callable, Type, TypeVar
import streamlit as st

# 새 핸들러와 포맷터 설정
logger = logging.getLogger(__name__)
logger.propagate = False  # 상위 로거로 메시지 전파 중지
for handler in logger.handlers[:]:
    logger.removeHandler(handler)
handler = logging.StreamHandler()
formatter = logging.Formatter('\n%(levelname)s [%(name)s] %(message)s')  # 로그 레벨이 동적으로 표시되도록 변경
handler.setFormatter(formatter)
logger.addHandler(handler)
# DEBUG와 INFO 중 원하는 레벨로 설정
logger.setLevel(logging.INFO)  # 기본 레벨은 INFO로 설정

T = TypeVar("T")

class Colors:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'

def log_io(func: Callable) -> Callable:
    """
    A decorator that logs the input parameters and output of a tool function.

    Args:
        func: The tool function to be decorated

    Returns:
        The wrapped function with input/output logging
    """

    @functools.wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Any:
        # Log input parameters
        func_name = func.__name__
        params = ", ".join(
            [*(str(arg) for arg in args), *(f"{k}={v}" for k, v in kwargs.items())]
        )
        # Execute the function
        result = func(*args, **kwargs)

        # Log the output
        if len(result.split("||")) == 3:
            status, code, stdout = result.split("||")
            logger.info(f"{Colors.RED}Coder - {status}\n{code}{Colors.END}")
            logger.info(f"{Colors.BLUE}\n{stdout}{Colors.END}")
            
            if "current_agent" in st.session_state:
                current_agent = st.session_state["current_agent"]
                st.session_state["tool_containers"][current_agent]["input"].markdown(f"Coder - {status}\n{code}")
                st.session_state["tool_containers"][current_agent]["output"].markdown(f"{stdout}")
        else:
            cmd = None
            if len(result.split("||")) == 2: cmd, stdout = result.split("||")
            logger.info(f"{Colors.RED}\nCoder - Tool {func_name} returned:\n{result}{Colors.END}")
            
            if "current_agent" in st.session_state:
                current_agent = st.session_state["current_agent"]
                if cmd != None: st.session_state["tool_containers"][current_agent]["input"].markdown(f"```bash\n{cmd}\n```")
                st.session_state["tool_containers"][current_agent]["output"].code(f"Coder - Tool {func_name} returned:\n{result}")
        return result

    return wrapper


class LoggedToolMixin:
    """A mixin class that adds logging functionality to any tool."""

    def _log_operation(self, method_name: str, *args: Any, **kwargs: Any) -> None:
        """Helper method to log tool operations."""
        tool_name = self.__class__.__name__.replace("Logged", "")
        params = ", ".join(
            [*(str(arg) for arg in args), *(f"{k}={v}" for k, v in kwargs.items())]
        )
        logger.debug(f"{Colors.RED}Tool {tool_name}.{method_name} called with parameters: {params}{Colors.END}")

    def _run(self, *args: Any, **kwargs: Any) -> Any:
        """Override _run method to add logging."""
        self._log_operation("_run", *args, **kwargs)
        result = super()._run(*args, **kwargs)
        logger.debug(f"{Colors.BLUE}\nCoder - Tool {self.__class__.__name__.replace('Logged', '')} returned: {result}{Colors.END}")
        return result


def create_logged_tool(base_tool_class: Type[T]) -> Type[T]:
    """
    Factory function to create a logged version of any tool class.

    Args:
        base_tool_class: The original tool class to be enhanced with logging

    Returns:
        A new class that inherits from both LoggedToolMixin and the base tool class
    """

    class LoggedTool(LoggedToolMixin, base_tool_class):
        pass

    # Set a more descriptive name for the class
    LoggedTool.__name__ = f"Logged{base_tool_class.__name__}"
    return LoggedTool
